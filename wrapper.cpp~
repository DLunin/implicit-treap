#include "implicit_treap.h"
#include <boost/python.hpp>
#include <boost/python/slice.hpp>
#include <string>
#include <limits>

using namespace std;
using namespace boost::python;

typedef persistent_treap<PyObject*> PersistentTreap;
typedef node_iterator<PyObject*> PersistentTreapIterator;


template <typename T>
string containter___str__(const T* cont) {
    string result;
    result += "[";
    bool atleast_once = false;
    for (auto current = t->cbegin(), end = t->cend(); current != end; current++) {
        atleast_once = true;
        result += call_method<string>((*current), "__repr__");
        result += ", ";
    }
    if (atleast_once) {
        result.pop_back();
        result.pop_back();
    }
    result += "]";
    return result;

}

string persistent_treap___str__(const PersistentTreap *t) {
    return "persistent_treap([" + containter___str__<PersistentTreap>(t) + "]";
}

string treap___str__(const Treap* t) {
    return "treap([" + containter___str__<Treap>(t) + "]";
}

PersistentTreap persistent_treap_pop(const PersistentTreap *t, long long pos = -1) {
    if (pos < 0) { 
        return t->pop_back();
    }
    return t->erase(pos);
}
boost_python_function_overloads(persistent_treap_pop_overloads, persistent_treap_pop, 1, 2)

void treap_pop(const Treap *t, long long pos = -1) {
    if (pos < 0) { 
        t->pop_back();
    }
    t->erase(pos);
}
boost_python_function_overloads(treap_pop_overloads, treap_pop, 1, 2)

template <typename TContainer>
TContainer container_get_slice(const TContainer *t, slice sl) {
    treap_size_t begin = 0, end = t->size();
    extract<treap_size_t> extract_begin(sl.start());  
    if (extract_begin.check()) 
        begin = extract_begin;
    extract<treap_size_t> extract_end(sl.stop());  
    if (extract_end.check())
        end = extract_end;
    return t->slice(begin, end);
}

boost::python::tuple persistent_treap_split(const PersistentTreap *t, treap_size_t pos) {
    auto res = t->split(pos);
    return boost::python::make_tuple(res.first, res.second);
}

PyObject* persistent_treap_iterator___next__(PersistentTreapIterator* self) {
    if (!self->is_end()) { 
        auto result = **self;
        (*self)++;
        return result;
    }
    else {
        PyErr_SetNone(PyExc_StopIteration);
        throw_error_already_set();
        return NULL;
    }
}

PersistentTreapIterator persistent_treap_iterator___iter__(PersistentTreapIterator* self) {
    return *self;
}

PersistentTreapIterator persistent_treap___iter__(const PersistentTreap *self) {
    return self->cbegin();
}

BOOST_PYTHON_MODULE(persistent_treap)
{
    class_<PersistentTreapIterator>("PersistentTreapIterator")
        .def("__next__", persistent_treap_iterator___next__)
        .def("__iter__", persistent_treap_iterator___iter__)
        .def(self == self)
        .def(self != self)
        ;

    PersistentTreap (PersistentTreap::*persistent_treap_insert_element)(treap_size_t, PyObject* const&) const = &PersistentTreap::insert;
    PersistentTreap (PersistentTreap::*persistent_treap_insert_persistent_treap)(treap_size_t, const PersistentTreap&) const = &PersistentTreap::insert;

    PersistentTreap (PersistentTreap::*persistent_treap_erase_single)(treap_size_t) const = &PersistentTreap::erase;
    PersistentTreap (PersistentTreap::*persistent_treap_erase_range)(treap_size_t, treap_size_t) const = &PersistentTreap::erase;
    
    class_<PersistentTreap>("PersistentTreap")
        .def("__len__", &PersistentTreap::size)
        .def("__str__", persistent_treap___str__)
        .def("__iter__", &PersistentTreap::cbegin)
        .def("append", &PersistentTreap::push_back)
        .def("pop", &persistent_treap_pop, persistent_treap_pop_overloads(args("self", "i"), "pop"))
        .def("__getitem__", &PersistentTreap::operator[], return_value_policy<copy_const_reference>())
        .def("__getitem__", &persistent_treap___getitem__)
        .def("split", persistent_treap_split)
        .def("insert", persistent_treap_insert_element)
        .def("insert", persistent_treap_insert_persistent_treap)
        .def("erase", persistent_treap_erase_single)
        .def("erase", persistent_treap_erase_range)
        .def(self + self)
        .def(self * treap_size_t())
        .def(treap_size_t() * self)
        //.def("set", &PersistentTreap::set)
        ;
    
    class_<Treap>("Treap")
        .def("__len__", &Treap::size)
        .def("__str__", treap___str__)
        .def("__iter__", &PersistentTreap::cbegin)
        .def("append", &PersistentTreap::push_back)
        .def("pop", &persistent_treap_pop, persistent_treap_pop_overloads(args("self", "i"), "pop"))
        .def("__getitem__", &PersistentTreap::operator[], return_value_policy<copy_const_reference>())
        .def("__getitem__", &persistent_treap___getitem__)
        .def("split", persistent_treap_split)
        .def("insert", persistent_treap_insert_element)
        .def("insert", persistent_treap_insert_persistent_treap)
        .def("erase", persistent_treap_erase_single)
        .def("erase", persistent_treap_erase_range)
        .def(self + self)
        .def(self * treap_size_t())
        .def(treap_size_t() * self)
        //.def("set", &PersistentTreap::set)
        ;
    
}
